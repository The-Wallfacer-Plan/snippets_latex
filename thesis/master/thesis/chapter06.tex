\chapter{全文总结}

本文主要针对程序演化过程中补丁验证这一情景，分析特定的补丁(\patch\ps )及该补丁所修复的程序错误(\patch\bs )，根据静态分析的方法对补丁程序的不相关分支进行削减，得到了受到补丁影响且影响原bug发生处的程序片段，通过对该程序子集的验证实现了对该补丁程序有选择地符号执行的工具\dryrun。

实现过程主要分为两部分：通过静态分析的方法削减程序中的不相关部分和通过添加符号执行语义及程序驱动。前者基于Andersen指向分析结果，根据控制流图及调用图得到可能从程序补丁处执行到程序出错处的路径上的所有程序语句组成的偏序集合，进一步通过程序切片的方法计算真实影响程序出错的程序区域\rbscope 。后者则需要对未在\rbscope 中定义但被使用的全局变量及外部形式参数符号化，同时添加符号执行工具可以理解的驱动程序。经过这样的修改，对新的编译单元进行符号执行，验证原补丁程序\patch 的正确性；当补丁\patch\ps 不正确时通过交叉验证验证\patch\ps 相对于\bug\ps 的错误性质。

为了对\dryrun 进行评估，我们对Coreutils中的12个手工添加的补丁进行了验证。\dryrun 在相对较短的时间内定位出程序中的错误所在，在性能上和KLEE对完整程序进行补丁验证相比大幅度提升，最高有1000倍的速度提升。这样的结果说明通过剔除不相关代码而有选择地进行符号执行的思路是可行的。

\dryrun 的局限也是显而易见的：首先，它并没有对符号执行工具KLEE的核心算法做修改，因此它受限于KLEE的执行机制。例如，KLEE对底层函数的建模是在系统调用层次上的，而遇到外部函数调用KLEE会终止符号执行而使用具体值带入执行；这使得\dryrun 在符号执行时不得不额外链接$\mu clibc$的LLVM中间代码，并对应用程序符号执行的同时仍然执行相关的libc函数。并且由于设计上的缺陷，KLEE本身具有很多不确定性，这给\dryrun 的性能评估带来了很大的困难。

其次，尽管通过程序削减减少了程序的大小，然而保留下来的程序中仍然可能存在大量的分支循环结构，这种情况下符号执行的代价仍然很大。\dryrun 选择性符号执行的效率受静态指向分析精度影响很大，然而生成\rbscope 时使用了上下文不敏感的Andersen分析，仍然不能达到很高精度，这可能扩大\rbscope 的大小；同时，当待验证程序中存在大量的全局变量时，\rbscope 有可能更大。并且，基于程序可达性分析的程序削减中，为了保证削减之后的程序可执行不得不在较为粗糙的程序基本块上进行削减。进一步，由于程序切片使用的是Mark Weiser提出的静态切片的方法，在过程间上仍然不能保证具有足够的精度。

最后，在给程序片段提供符号执行的驱动程序时目前的做法是不加选择地将入口函数中的参数替换为符号化的实际参数带入执行，这忽略了程序实际执行时的该参数的前置条件，因此会增多程序的执行路径从而增加符号执行的时间，同时也给程序验证带来了错误肯定。

针对上文提到的\dryrun 的一些缺陷，我们拟在后续的工作中做如下改进：
\begin{itemize}
\item 结合LLVM提供的编译优化，在现有的Andersen指向分析算法上对LLVM中间表达形式上的指令作更为精确的建模，以得到更准确的指向结果。
% \item 以程序可达性分析中的“子基本块”为基本单位，在保证程序可执行的基础上，在更细的粒度上进行程序转换。
\item 采用Susan Horwitz等人提出的过程间程序切片的方法~\upcite{inter-slice}，在程序依赖图上对程序进行切片以获得更高的精度。
\item 通过静态分析的方法计算需要符号化的变量值的最弱前置条件，将该条件作为符号执行的前置条件来模拟真实的执行，进一步减少补丁验证的带来的错误肯定，并提高符号执行的效率。
\item 不直接削减程序本身而仅仅标记源程序的不属于\rbscope 的代码片段，修改符号执行器执行逻辑，仅对\rbscope 中的代码进行符号执行。这将避免了在程序削减中因为需要保证程序可执行带来的约束限制，同时可以获得额外的动态执行路径信息，基于这些信息可以做进一步的优化。
\item 使用更为前沿的符号执行工具，有效处理底层的或第三方库函数中外部函数带来的不准确。
\end{itemize}

\dryrun 仍处于实验阶段，还存在诸多不足。然而实验结果表明，\dryrun 有选择地进行符号执行的方式大幅度缩短了补丁验证的周期。这使得我们相信，经过进一步合理的改进\dryrun 可以应用于大型复杂软件的开发中。