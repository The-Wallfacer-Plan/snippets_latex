\chapter{绪论}
\label{chap:intro}

\section{研究背景}
\label{sec:background}

\subsection{课题的研究意义}
\label{sec:meaning}

补丁验证是一个正日益受到学术界和工业界关注的问题~\upcite{apsys12, fixation, dora}，它能有效地防止包含错误的程序补丁被不适当地添加进新版本程序代码中。

软件开发过程中，经常需要对含有错误(臭虫，bug)的程序提交补丁(patch)。然而错误的补丁有可能是不完全的，即：该程序补丁仅修复了部分程序输入导致的程序错误，但对于另外一些可能的输入仍然会引发错误。另一方面，这些补丁可能是一些回归补丁(regression patch)，它引发了在原有程序中不存在的新的错误。更有甚者，这些补丁可能兼有这两种错误。错误补丁的存在使得程序不再健壮，甚至会增加后续过程中产生正确的补丁的难度。

为此，业界需要采取有效的方法来验证经过修改的程序的正确性。在理论上可以通过形式化证明、静态分析和软件测试等方法来提高补丁的可靠性。形式化证明的方法可以完全地验证程序的正确性，然而由于软件所使用程序语言本身的复杂性，且基于理论推导的验证过程时间开销很大，该方法通常不能用于现实中的程序。语法上的分析可以检测语法错误或潜在的可能的语义错误，一般的编译器前端可以检测这类较为低级的错误；通过数据流、控制流、指向分析等静态分析的手段可以检测出程序中如变量越界等典型错误，然而这些方法检测的错误类型仍然极其有限。因此通常仅采用轻量级的静态分析作为辅助检测程序错误的手段。

现实中往往通过人工编写大量的测试用例进行测试以提高软件的质量。手动编写测试的本身存在一些不可避免的问题。首先，测试用例往往不能达到较高的语句覆盖率；现实中测试人员对待测程序理解不够深入，难以生成绝大多数可行的程序输入，分支覆盖率和路径覆盖率很低。对补丁程序的不完整测试会带来严重的后果，一个不正确的补丁可能会隐藏原先的错误所在，使其更为隐蔽，大大增加得到最终正确补丁的难度。近期的一项研究结果表明，大约$14.8\%$-$25\%$的补丁是不正确的~\upcite{BuggyFix}。 事实上，有$38\%$-$50\%$的Bugzilla数据库\footnote{Bugzilla首页: http://www.bugzilla.org/}中的bug被重新打开(reopen)~\upcite{fixation}。对完整的待验证补丁程序进行高覆盖率的测试需要很大的时间开销。这一过程通常包含多种测试手段，包括单元测试、回归测试，有时还需要压力测试；这极有可能会要求更大的测试用例集合。然而如果对程序补丁的验证不够及时，一般会直接导致程序员生产效率的下降。这是因为该过程是软件演化过程中的一个关键步骤，它需要不断迭代进行，这是一个交互的过程。一项研究~\upcite{maintenance}表明，程序员花费了$50\%$-$80\%$的时间用于检测、定位故障并修正错误。因此，工业界迫切需要有一种既能够提高补丁验证质量又可以加速自动验证的新技术。

近些年来符号执行(symbolic execution)在生成高覆盖率的测试用例集和发现复杂软件中潜在错误上有了新的突破，正日益受到研究人员和工业界的关注。其基本思想是用符号值而不是具体值作为程序的输入进行执行，根据执行路径上不同的路径条件(path condition)，藉由约束求解器(constraint solver)来验证条件是否可行；当得知该条件可以满足时，将符合该条件约束的所有可行的值作为原有程序的输入进行具体的程序执行。由于该过程类似于以可行的程序输入真实动态执行程序本身，故从理论上来说符号执行可以检测出程序中可能发生的任何错误，对静态分析方法无法检测的错误检测尤为有效。由于当前技术水平限制，现有符号执行工具都不是完全意义上的符号执行，然而比起基于手工的测试仍会有更高的覆盖率~\upcite{KLEE}。

由于svn，git等软件配置管理(Software Configuration Management)工具的普及，人们可以方便地追踪程序变化历史。
在对国内外知名代码仓库中的bug提交结果分析之后，我们发现补丁程序和原有含有错误的程序的改动相对不大，程序补丁往往仅修复单个错误，其影响通常限于程序的局部~\upcite{APSYS11}，且很少涉及程序的核心语义~\upcite{DeltaExecution}。这使得没有必要对整个程序使用符号执行的工具验证。同时，由于符号执行的路径爆炸（path explosion）及约束求解器的限制，对现实中的程序完整地进行符号执行也是不可行的。

基于上述观察，本课题提出有选择性的符号执行方法以验证所给补丁正确性，力求减少时间上的开销。首先依据程序的改动部分(patch site)和原有程序错误发生节点(bug site)作为配置信息，基于指向分析方法，利用调用图信息、程序可达性信息及影响性结果，削减不相关程序，得到仅和补丁及原有错误相关的程序片段，添加符号执行的语义和驱动程序，通过对这一程序子集合进行符号执行以检测原有程序中可能存在的错误。

\subsection{国内外研究现状}
\label{sec:current}
符号执行(symbolic execution)的基本思想最早于上世纪80年代由Robert S.Boyer等人提出~\upcite{SELECT}， 后经James C. King等~\upcite{EFFIGY}加以精化并应用于软件测试领域。然而由于经典的符号执行没有高效的算法实现、当时计算机计算能力有限等因素制约，符号执行不能应用于现实程序中。

针对符号执行的路径爆炸、求解器约束等问题，自2000年以来，学者们针对测试用例生成这一场景，从不同角度提出了提高符号执行覆盖率的方法，增强了检测程序bug的能力。

首先是在符号执行模型上的改进。现代的符号执行系统一般有如下两种类型。
\begin{itemize}
\item “将具体输入和符号执行结合”的方法，由P. Godefroid等人于2005年提出，最早应用于执行工具DART~\upcite{DART}中。和经典符号执行的方法不同，DART采用随机生成的具体值(concrete value)作为程序输入，在每一个可能的程序分叉处，取反给定的输入值的分支约束条件，通过约束求解器计算与当前输入值不同的路径，以实现对路径的遍历。这种将具体值(CONCrete)和符号值(symbOLIC)结合执行的生成测试用例的方法又被称作CONCOLIC Testing。这样的执行会使得部分可行的分支条件被忽略而遗漏很多可行的执行路径，但是却能部分解决原本约束求解器无法求解的非线性约束，提高了符号执行的速度。由此诞生的另外一些工具如DiSE~\upcite{DiSE}、CUTE~\upcite{CUTE}、jCUTE~\upcite{CUTE}、SAGE~\upcite{SAGE}也基于这一思想。
  \item “由执行生成测试”(Execution-Generated Testing，EGT)的方法，其典型实现为EXE~\upcite{EXE}和KLEE~\upcite{KLEE}。EGT工具把符号值作为程序的输入，在每一处可能产生错误的危险操作上计算可能的条件，由约束求解器得到符号的约束条件并给出可行的具体值，从而生成不同的具体程序状态(states)。EGT在每一含有确定具体值的语句处对程序进行解释执行；当符号执行工具察觉到约束求解器无法求解约束条件时(如遇到外部函数调用或浮点型比较)，则使用具体值带入执行。基于这一方法的应用有DDT~\upcite{kuznetsov2010testing}，ESD~\upcite{zamfir2010execution}，RevNIC~\upcite{chipounov2010reverse}等。
\end{itemize}

另一个研究方向是对于需要符号执行的程序的片段的选择性执行上的优化。对大型程序符号执行的代价较大，但实际情形中往往仅需对小部份程序进行验证。
\begin{itemize}
\item Vitaly Chipounov等人给出了$S^2E$这样一个分析程序的平台~\upcite{S2E}，使得可以通过用户选用不同粒度的符号执行策略对程序进行验证；例如$S^2E$可以选择是否对指定库函数进行符号执行、如何执行外部函数等，这也使得对不能得到源代码的二进制程序进行符号执行成为可能。
\item Woodpecker~\upcite{WOODPECKER}是另一类有选择的符号执行方法，它只关注程序中的一些特定规则(如打开的文件在程序结束前必须关闭等)，使用符号执行对这些规则进行验证；由于特定规则会有一些特定模式，可以避免在所有路径上符号执行。
\end{itemize}

\section{研究内容}
\label{sec:brief}

\subsection{课题的研究目标}
\label{sec:goal}

静态分析和符号执行都有其自身的优势及缺陷。静态分析可以在不执行程序的前提下检测程序中可能的错误，这避免了程序执行带来的破坏；它是完全的(complete)但并不充分(sound)：只有当没有一条可行的路径会运行至程序的错误节点~\upcite{rule}或触发该错误的最弱前置条件(weakest precondition)不可满足~\upcite{fixation}才认为该路径是正确的；否则它仅仅保守地警告可能的错误补丁而不提供精确的运行时信息。因此这会产生大量的错误肯定(false positive)，并且由于不能得到触发错误的具体程序输入，很多情况下会增大而非减少程序员的负担。另一方面，因为符号执行真实执行符号化的程序输入，这使得其结果是充分的。由于其具体值的求解是由约束求解器(constraint solver)完成的，这往往会比人工编写的测试用例具有更高的覆盖率，从而比手工测试更为完全~\upcite{ContinuousTest, dora}；和静态分析相反，符号执行引擎总可以得到引发错误的具体输入值。

纯静态分析和符号执行都面临着扩展性问题。对于大中型规模的程序而言，它们通常都需要相当长的时间才可以完成。为了取得精确的结果，静态分析需要得到流敏感(flow sensitive)、上下文敏感(context sensitive)甚至路径敏感(path sensitive)的分析结果，这使得静态方法对大型复杂程序束手无策。对大规模的程序进行符号执行的代价也是巨大的，状态爆炸(path explosion)使得符号执行工具难以获得高的语句覆盖和分支覆盖，约束求解器求解约束条件的限制使得在理论上无法对部分程序进行符号执行。

我们针对软件演化这一场景，希望通过选择性符号执行的方法仅对补丁程序中的相关部分进行符号执行，结合静态分析和动态符号执行各自的优势，正确且高效地对补丁进行验证。
我们的研究目标如下：
\begin{enumerate}
\item 在大部分情况下，当补丁程序存在错误时，有选择的符号执行须比一般的符号执行工具花费更少的时间检测出程序中的错误。
\item 有选择的符号执行在检测出错误时需要得到触发该错误的测试用例，将之带入原有的完整程序中时，需要正确触发程序中的错误。
\item 当补丁程序存在错误时，需进一步分析该错误是回归错误或是由于补丁只修复了部分错误造成的。
\item 当程序补丁是正确的情况下，选择性符号执行不应该得到该补丁程序存在错误这一结论。
\end{enumerate}

然而由于符号执行自身的局限性，且选择性符号执行因为不是验证程序本身而是程序的相关子集，因此上述目标往往不能完全实现。

\subsection{本文的工作}
\label{sec:contr}

我们建立了\dryrun\footnote{\dryrun 是“守护者”的意思， 也是Symbolic Execution Represents A PHase的缩写。}补丁验证系统，它结合了静态分析和基于动态符号执行的自动化测试的优点，大大提高了程序的可扩展性。\dryrun 核心思想较为简单：
\begin{enumerate}
\item 将问题定位到所做补丁处及错误发生处的所有可能的程序执行路径，并进一步通过静态分析的方法去除和补丁修改无关的部分和不影响错误发生的程序片段，最终得到一个局部的程序片段。该片段被称为 \rbscope ，其含义为出错程序的根本原因(Root cause)和程序出错点(Bug site)的区域(SCOPE)。
\item 给\rbscope 添加对应的入口函数信息，并添加符号执行的语义，得到符号执行引擎可以执行的编译单元。使用符号执行引擎对该程序片段解释执行，通过符号执行的结果判断所做补丁的正确性。同时，为分析补丁程序和原有程序的关系(即交叉验证)，将前述静态分析应用于未添加补丁的程序，并通过类似方法将未修改程序添加入符号分析工具执行的编译单元中。这样可以根据两个版本程序间路径\cndash 路径关系的比较结果，判断bug是否已被修复、仅部分被修复或补丁引发了新的错误。
\end{enumerate}

因为没有考虑到\rbscope 之外程序的准确前置条件，这样的方法仍然是不充分的；然而，由于完整性和速度方面的提升，使得这一权衡是值得的。\dryrun 通过对十多个GNU Coreutils(详见\autoref{chap:eval}\nameref{chap:eval})中的错误补丁进行检测，找到了所有的补丁错误，和KLEE对完整程序执行相比，最高可达到1000倍左右的性能提高。

% --------------------------------------------

本课题是建立在静态分析框架LLVM和符号执行器KLEE的基础上的，我们希望给定bug程序和其补丁程序，经过一系列地中间代码转化，生成一份LLVM指令代码文件作为KLEE的输入，在符号执行结束后分析补丁程序的正确性以及是否引入新的错误等；如果该补丁并不正确，还需要得到引发程序错误的输入用例。

为了实现该课题的研究目标，研究主要集中在以下五方面的内容：
\begin{enumerate}[label={(\arabic*)}]
\item 理解LLVM中间表达形式（LLVM IR）的组成，掌握生成、分析、转化中间代码的基本方法。
\item 在LLVM中间代码上根据Andersen指向算法，给出编译单元内调用图和修改集合信息。
\item 基于对程序补丁处及程序错误发生处的过程间可达性分析削减程序中的不可达部分。
\item 以程序出错位置作为后向切片准则， 实现所给程序范围内的后向切片， 保留从程序片段入口处可能影响程序出错处的指令集合。
\item 通过程序转化，在中间代码层次给程序添加符号执行引擎可理解的语义及程序入口，生成符号执行的驱动程序。
\end{enumerate}

本论文的主要贡献如下：
\begin{itemize}
\item 提出了一种新的补丁验证的方法，使得可以通过有选择的符号执行对补丁进行有效并高效地验证。
\item 计算所有可能的从补丁处至错误发生处的极小相关程序范围。
\item 给出了如何由现有程序的\rbscope 生成可供验证驱动程序进行交叉验证的算法，使得可以通过符号执行结果对“补丁程序是否完整或引入新的错误”这一问题给出正确解释。
\item 实现了该思想的工具原型\dryrun ，使得可以对Coreutils等实际复杂程序中的补丁进行验证。
\end{itemize}

\section{本文的内容组织}
\label{sec:struct}
本文共包括六章，各章的内容组织如下：
\begin{itemize}
\item 第一章是文章的绪论部分。主要说明本课题的研究意义，分析相关领域的国内外研究现状，然后介绍课题的研究目标以及所做的工作；最后说明了本文的组织结构。
\item 第二章从宏观上介绍了有选择性符号执行验证技术，这是\dryrun 工具的理论基础。本章详细阐述了静态分析技术结合符号执行的理论基础及现有的可用基础框架，首先解释了符号执行工具的基本概念及具体应用，之后介绍了建立在LLVM中间表达形式上的符号执行引擎KLEE的原理，最后通过一个具体的例子说明了有选择符号执行用于程序验证的场景。
\item 第三章是\dryrun 的前半部分实现，介绍了\rbscope 的生成过程，主要介绍将程序中的不相关部分通过静态分析进行删减的方法。详细说明了\rbscope 生成流程图的方法，接着着重介绍了关注点配置、指向分析、调用图的生成等用于程序转化的准备工作，最终分别阐述了基于未调用函数的削减、基于程序可达性的削减及基于程序影响性分析的削减方法。
\item 第四章是补丁验证，是\dryrun 的后半部分实现。解释了如何根据\rbscope 使用代码转化技术合成为符号执行工具可理解的程序并对之验证，同时给出了交叉验证的算法；最终针对一类难以进行符号执行的程序提出了使用用户提供初始化的方法来辅助验证的方案。
\item 第五章是实验与评估。首先给出了\dryrun 用于补丁验证的一般实验流程。之后介绍了具体的实验方案：从类Unix系统下常用的Coreutils的程序集中无差别地选取数十个程序并手工添加补丁，评估了\dryrun 验证补丁的正确性和高效性，同时分析了\dryrun 带来的错误肯定(false positive)及交叉编译带来的回归错误。
\item 第六章是总结和展望。本章对本文的研究工作进行了总结，阐述了\dryrun 存在的不足之处，并提出未来工作中需要做的改进。
\end{itemize}
